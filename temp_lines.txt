   1: from __future__ import annotations
   2: 
   3: """Pygame App for the Tennis Match Simulator.
   4: 
   5: Run with: `python -m gui.app`.
   6: 
   7: Controls:
   8:   - Space/Click: next point
   9:   - R: replay current point
  10:   - S: toggle speed (shows current multiplier)
  11:   - Q/Esc: quit
  12: """
  13: 
  14: import argparse
  15: import sys
  16: from typing import Optional
  17: 
  18: try:
  19:     import pygame
  20: except Exception as e:  # pragma: no cover - runtime dependency hint
  21:     print("Pygame is required for GUI. Install via: pip install pygame", file=sys.stderr)
  22:     raise
  23: 
  24: from tennis.engine import MatchConfig
  25: from model.adapter import PointStream, PointOutcome
  26: 
  27: from . import constants as C
  28: from .court import Court
  29: from .sprites import PlayerSprite, BallSprite
  30: from .animator import RallyAnimator
  31: from .hud import HUD
  32: 
  33: 
  34: def parse_args(argv=None):
  35:     p = argparse.ArgumentParser(description="Tennis GUI (Pygame)")
  36:     p.add_argument("--player-a", default=None)
  37:     p.add_argument("--player-b", default=None)
  38:     p.add_argument("--sets", type=int, choices=[3, 5], default=None)
  39:     p.add_argument("--bias", type=int, default=None)
  40:     p.add_argument("--seed", type=int, default=None, help="Deterministic seed (optional)")
  41:     p.add_argument("--no-prompt", action="store_true", help="Skip GUI prompt and use provided flags")
  42:     p.add_argument("--width", type=int, default=C.DEFAULT_WINDOW[0])
  43:     p.add_argument("--height", type=int, default=C.DEFAULT_WINDOW[1])
  44:     p.add_argument("--fps", type=int, default=C.TARGET_FPS)
  45:     return p.parse_args(argv)
  46: 
  47: 
  48: def run(argv=None) -> int:
  49:     args = parse_args(argv)
  50: 
  51:     def is_valid_name(s: str) -> bool:
  52:         import re
  53:         s = (s or "").strip()
  54:         return bool(s) and re.fullmatch(r"[A-Za-z ]+", s) is not None
  55: 
  56:     def is_valid_sets(v: Optional[int]) -> bool:
  57:         return v in (3, 5)
  58: 
  59:     def is_valid_bias(v: Optional[int]) -> bool:
  60:         return isinstance(v, int) and 0 <= v <= 100
  61: 
  62:     pygame.init()
  63:     pygame.display.set_caption("Tennis Match Simulator - GUI")
  64:     flags = pygame.RESIZABLE | pygame.DOUBLEBUF
  65:     try:
  66:         screen = pygame.display.set_mode((args.width, args.height), flags, vsync=1)
  67:     except TypeError:
  68:         screen = pygame.display.set_mode((args.width, args.height), flags)
  69:     clock = pygame.time.Clock()
  70: 
  71:     court = Court(screen.get_size())
  72:     hud = HUD(screen)
  73: 
  74:     # Prepare sprites (positions set during animation planning)
  75:     # Sprite radii scale with pixels-per-meter
  76:     px_per_m = court.layout.scale
  77:     player_radius = max(8, int(px_per_m * 0.22))
  78:     ball_radius = max(3, int(px_per_m * 0.08))
  79:     player_a = PlayerSprite(C.PLAYER_A_COLOR, player_radius, court.to_px(C.COURT_WIDTH_M / 2, -1))
  80:     player_b = PlayerSprite(C.PLAYER_B_COLOR, player_radius, court.to_px(C.COURT_WIDTH_M / 2, C.COURT_LENGTH_M + 1))
  81:     home_a_px, home_b_px = court.home_positions_px()
  82:     ball = BallSprite(ball_radius, court.to_px(C.COURT_WIDTH_M / 2, C.NET_Y_FROM_TOP_M))
  83: 
  84:     animator = RallyAnimator(court, seed=args.seed)
  85:     # Default to 0.75x if present; else first step
  86:     speed_idx = C.SPEED_STEPS.index(0.75) if 0.75 in C.SPEED_STEPS else 0
  87:     hud.update(speed_mult=C.SPEED_STEPS[speed_idx])
  88: 
  89:     # Prompt for configuration unless flags provided and --no-prompt
  90:     cfg: Optional[MatchConfig] = None
  91:     stream = None
  92:     current_outcome: Optional[PointOutcome] = None
  93:     point_counter = 0
  94: 
  95:     def draw_prompt(fields, active_idx):
  96:         # Solid black background to avoid overlay with HUD/court
  97:         screen.fill((0, 0, 0))
  98:         title_font = pygame.font.SysFont("arial", 28)
  99:         font = pygame.font.SysFont("arial", 22)
 100:         y = 80
 101:         title = title_font.render("Enter Match Setup", True, C.HUD_TEXT_COLOR)
 102:         screen.blit(title, ((screen.get_width() - title.get_width()) // 2, y))
 103:         y += 50
 104:         labels = [
 105:             ("Player A:", fields[0]),
 106:             ("Player B:", fields[1]),
 107:             ("Sets (3 or 5):", fields[2]),
 108:             ("Starting Bias (0..100):", fields[3]),
 109:         ]
 110:         x = 80
 111:         for i, (lab, val) in enumerate(labels):
 112:             txt = f"{lab} {val}"
 113:             img = font.render(txt, True, (255, 255, 255) if i == active_idx else C.HUD_TEXT_COLOR)
 114:             screen.blit(img, (x, y))
 115:             y += img.get_height() + 18
 116:         hint = pygame.font.SysFont("arial", 18).render("Enter to confirm field, Tab to next, Esc to quit", True, C.HUD_TEXT_COLOR)
 117:         screen.blit(hint, (x, y + 8))
 118:         pygame.display.flip()
 119: 
 120:     def run_prompt():
 121:         nonlocal cfg
 122:         fields = [args.player_a or "", args.player_b or "", str(args.sets or 3), str(args.bias or 50)]
 123:         active = 0
 124:         while True:
 125:             draw_prompt(fields, active)
 126:             for event in pygame.event.get():
 127:                 if event.type == pygame.QUIT:
 128:                     return False
 129:                 if event.type == pygame.KEYDOWN:
 130:                     if event.key in (pygame.K_ESCAPE, pygame.K_q):
 131:                         return False
 132:                     if event.key == pygame.K_TAB:
 133:                         active = (active + 1) % 4
 134:                         break
 135:                     if event.key == pygame.K_RETURN:
 136:                         if active < 3:
 137:                             active += 1
 138:                         else:
 139:                             name_a, name_b, sets_s, bias_s = fields
 140:                             try:
 141:                                 sets_v = int(sets_s)
 142:                                 bias_v = int(bias_s)
 143:                             except Exception:
 144:                                 break
 145:                             if not (is_valid_name(name_a) and is_valid_name(name_b)):
 146:                                 break
 147:                             if not is_valid_sets(sets_v) or not is_valid_bias(bias_v):
 148:                                 break
 149:                             cfg = MatchConfig(
 150:                                 player_a=name_a.strip(),
 151:                                 player_b=name_b.strip(),
 152:                                 max_sets=sets_v,
 153:                                 starting_bias=bias_v,
 154:                                 seed=None,
 155:                             )
 156:                             return True
 157:                         break
 158:                     if event.key == pygame.K_BACKSPACE:
 159:                         if fields[active]:
 160:                             fields[active] = fields[active][:-1]
 161:                         break
 162:                     ch = event.unicode
 163:                     if active in (0, 1):
 164:                         if ch.isalpha() or ch == " ":
 165:                             fields[active] += ch
 166:                     elif active == 2:
 167:                         if ch.isdigit() and len(fields[active]) < 1:
 168:                             fields[active] += ch
 169:                     else:
 170:                         if ch.isdigit() and len(fields[active]) < 3:
 171:                             fields[active] += ch
 172:             pygame.time.delay(10)
 173: 
 174:     if not args.no_prompt:
 175:         ok = run_prompt()
 176:         if not ok:
 177:             pygame.quit()
 178:             return 0
 179:     else:
 180:         # Validate flags; fallback to defaults if invalid/empty
 181:         raw_a = (args.player_a or "").strip()
 182:         raw_b = (args.player_b or "").strip()
 183:         name_a = raw_a if is_valid_name(raw_a) else "Player A"
 184:         name_b = raw_b if is_valid_name(raw_b) else "Player B"
 185:         sets_v = args.sets or 3
 186:         bias_v = args.bias if args.bias is not None else 50
 187:         cfg = MatchConfig(
 188:             player_a=name_a,
 189:             player_b=name_b,
 190:             max_sets=sets_v,
 191:             starting_bias=bias_v,
 192:             seed=args.seed,
 193:         )
 194: 
 195:     # Update HUD with chosen names/settings
 196:     hud.update(name_a=cfg.player_a, name_b=cfg.player_b, best_of=cfg.max_sets)
 197: 
 198:     # Prepare model point stream now that cfg is set
 199:     stream = PointStream(cfg)
 200: 
 201:     def draw_everything():
 202:         screen.fill((10, 18, 24))
 203:         court.draw(screen)
 204:         player_a.draw(screen)
 205:         player_b.draw(screen)
 206:         ball.draw(screen)
 207:         hud.draw()
 208:         pygame.display.flip()
 209: 
 210:     current_server_is_a = False
 211:     last_outcome: Optional[PointOutcome] = None
 212: 
 213:     def plan_for_outcome(outcome: PointOutcome):
 214:         # Set speed
 215:         animator.set_speed_multiplier(C.SPEED_STEPS[speed_idx])
 216:         # Place players near serve/return positions for this point
 217:         nonlocal current_server_is_a
 218:         current_server_is_a = outcome.server == "A"
 219:         serve_pos_m, recv_pos_m = court.serve_positions(current_server_is_a, outcome.side)
 220:         player_a.move_to(court.to_px(*serve_pos_m if current_server_is_a else recv_pos_m))
 221:         player_b.move_to(court.to_px(*recv_pos_m if current_server_is_a else serve_pos_m))
 222:         # Plan animation
 223:         animator.plan(point_counter, current_server_is_a, outcome.side, outcome.winner, outcome.reason)
 224: 
 225:     running = True
 226:     playing_anim = False
 227:     # Terminal overlay (e.g., OUT / MISS / NET)
 228:     overlay_pos = None
 229:     overlay_text = None
 230:     overlay_color = (255, 255, 255)
 231:     overlay_timer = 0.0
 232: 
 233:     target_aspect = (args.width / args.height) if args.height else (C.DEFAULT_WINDOW[0] / C.DEFAULT_WINDOW[1])
 234: 
 235:     # Hit markers for racket contact flashes
 236:     hit_markers: list[tuple[tuple[float, float], tuple[int,int,int], float]] = []  # (pos, color, ttl)
 237:     hit_indices_seen: set[int] = set()
 238: 
 239:     while running:
 240:         dt = clock.tick(args.fps) / 1000.0
 241: 
 242:         for event in pygame.event.get():
 243:             if event.type == pygame.QUIT:
 244:                 running = False
 245:             elif event.type == pygame.VIDEORESIZE:
 246:                 # Enforce constant aspect ratio
 247:                 cur_w, cur_h = screen.get_size()
 248:                 dw = abs(event.w - cur_w)
 249:                 dh = abs(event.h - cur_h)
 250:                 if dw >= dh:
 251:                     new_w = max(320, event.w)
 252:                     new_h = int(round(new_w / target_aspect))
 253:                 else:
 254:                     new_h = max(240, event.h)
 255:                     new_w = int(round(new_h * target_aspect))
 256:                 try:
 257:                     screen = pygame.display.set_mode((new_w, new_h), flags, vsync=1)
 258:                 except TypeError:
 259:                     screen = pygame.display.set_mode((new_w, new_h), flags)
 260:                 court.resize((new_w, new_h))
 261:                 # Recompute sprite sizes
 262:                 px_per_m = court.layout.scale
 263:                 pr = max(8, int(px_per_m * 0.22))
 264:                 br = max(3, int(px_per_m * 0.08))
 265:                 player_a.radius_px = pr
 266:                 player_b.radius_px = pr
 267:                 ball.radius_px = br
 268:                 home_a_px, home_b_px = court.home_positions_px()
 269:             elif event.type == pygame.KEYDOWN:
 270:                 if event.key in (pygame.K_ESCAPE, pygame.K_q):
 271:                     running = False
 272:                 elif event.key == pygame.K_SPACE:
 273:                     playing_anim = True
 274:                 elif event.key == pygame.K_r:
 275:                     # Always replay the previously completed point
 276:                     if last_outcome is not None:
 277:                         current_outcome = last_outcome
 278:                         plan_for_outcome(last_outcome)
 279:                         animator.reset_playback()
 280:                         playing_anim = True
 281:                 elif event.key == pygame.K_s:
 282:                     speed_idx = (speed_idx + 1) % len(C.SPEED_STEPS)
 283:                     mul = C.SPEED_STEPS[speed_idx]
 284:                     animator.set_speed_multiplier(mul)
 285:                     hud.update(speed_mult=mul)
 286:             elif event.type == pygame.MOUSEBUTTONDOWN:
 287:                 playing_anim = True
 288: 
 289:         # If no current outcome, fetch next
 290:         if current_outcome is None and (not hud.state.match_over):
 291:             try:
 292:                 current_outcome = next(stream)
 293:                 point_counter += 1
 294:                 # Update HUD to reflect model state after this point
 295:                 hud.update(
 296:                     game_text=current_outcome.game_text,
 297:                     games=current_outcome.games,
 298:                     sets=current_outcome.sets,
 299:                     bias=current_outcome.bias,
 300:                     match_over=current_outcome.match_over,
 301:                     match_winner_name=current_outcome.match_winner_name,
 302:                 )
 303:                 plan_for_outcome(current_outcome)
 304:                 animator.reset_playback()
 305:                 playing_anim = True
 306:                 # do not update last_outcome or last_point until animation completes
 307:             except StopIteration:
 308:                 hud.update(match_over=True, match_winner_name=hud.state.match_winner_name)
 309: 
 310:         # Animate if requested
 311:         if playing_anim and current_outcome is not None:
 312:             def draw_ball_at(pos_px):
 313:                 ball.move_to(pos_px)
 314: 
 315:             def move_players(ball_pos, seg_index, seg, scaled_dt, local_t):
 316:                 # Determine roles from segment attribution if available
 317:                 striker_is_a = getattr(seg, 'striker_is_a', None)
 318:                 if striker_is_a is None:
 319:                     striker_is_a = current_server_is_a if (seg_index % 2 == 0) else (not current_server_is_a)
 320:                 receiver_is_a = not striker_is_a
 321:                 step_px = C.PLAYER_SPEED_MPS * court.layout.scale * (scaled_dt)
 322:                 # Receiver chases the live ball. For terminal OUT by loser, give up early.
 323:                 recv_step = step_px
 324:                 if seg.kind == 'out':
 325:                     winner_is_a = (current_outcome.winner == 'A')
 326:                     is_miss_terminal = (striker_is_a == winner_is_a)
 327:                     is_out_by_loser = not is_miss_terminal
 328:                     if is_out_by_loser:
 329:                         # Slow immediately; stop after 20% of segment
 330:                         if local_t > 0.2:
 331:                             recv_step = 0.0
 332:                         else:
 333:                             recv_step *= 0.4
 334:                 if receiver_is_a:
 335:                     player_a.move_towards(ball_pos, recv_step)
 336:                 else:
 337:                     player_b.move_towards(ball_pos, recv_step)
 338:                 # Striker recovers toward their home baseline center
 339:                 if striker_is_a:
 340:                     player_a.move_towards(home_a_px, step_px * 0.8)
 341:                 else:
 342:                     player_b.move_towards(home_b_px, step_px * 0.8)
 343: 
 344:                 # Add a small racket/contact hint at the start of each relevant segment
 345:                 if seg.kind in ('flight','out','net') and local_t < 0.05 and seg_index not in hit_indices_seen:
 346:                     color = C.PLAYER_A_COLOR if striker_is_a else C.PLAYER_B_COLOR
 347:                     hit_markers.append((seg.start_px, color, 0.25))
 348:                     hit_indices_seen.add(seg_index)
 349: 
 350:             cont = animator.update_and_draw(screen, dt, draw_ball_at, actors_update=move_players)
 351:             if not cont:
 352:                 playing_anim = False
 353:                 # Prepare a brief terminal overlay marker
 354:                 segs = animator.preview_trajectory(None)
 355:                 if segs:
 356:                     last = segs[-1]
 357:                     overlay_pos = last.end_px
 358:                     if current_outcome is not None:
 359:                         if current_outcome.reason == "Out":
 360:                             overlay_text = "OUT"
 361:                             overlay_color = (236, 88, 64)
 362:                         elif current_outcome.reason == "Net":
 363:                             overlay_text = "NET"
 364:                             overlay_color = (200, 170, 0)
 365:                         else:
 366:                             overlay_text = "MISS"
 367:                             overlay_color = (220, 220, 220)
 368:                         overlay_timer = 0.9
 369:                 # Now that animation finished, update HUD last_point and last_outcome
 370:                 if current_outcome is not None:
 371:                     hud.update(last_point=(f"{current_outcome.reason}: {(current_outcome.name_a if current_outcome.winner=='A' else current_outcome.name_b)} won the point"))
 372:                     last_outcome = current_outcome
 373:                 current_outcome = None
 374: 
 375:         # Draw scene
 376:         draw_everything()
 377:         # Draw hit markers (decay over time)
 378:         if hit_markers:
 379:             next_markers = []
 380:             for (hx, hy), c, ttl in hit_markers:
 381:                 ttl -= dt
 382:                 if ttl > 0:
 383:                     pygame.draw.circle(screen, c, (int(hx), int(hy)), 6, 2)
 384:                     next_markers.append(((hx, hy), c, ttl))
 385:             hit_markers = next_markers
 386:         # Draw terminal overlay briefly after point ends
 387:         if overlay_timer > 0 and overlay_pos is not None and overlay_text:
 388:             overlay_timer = max(0.0, overlay_timer - dt)
 389:             label = pygame.font.SysFont("arial", 24, bold=True).render(overlay_text, True, overlay_color)
 390:             lx = int(overlay_pos[0] + 10)
 391:             ly = int(overlay_pos[1] - 14)
 392:             bg = pygame.Surface((label.get_width() + 8, label.get_height() + 4), pygame.SRCALPHA)
 393:             bg.fill((0, 0, 0, 150))
 394:             screen.blit(bg, (lx - 4, ly - 2))
 395:             screen.blit(label, (lx, ly))
 396:             # Marker shapes
 397:             import pygame as _pg
 398:             if overlay_text == "OUT":
 399:                 # Draw a small red X at terminal point
 400:                 x0, y0 = int(overlay_pos[0]), int(overlay_pos[1])
 401:                 l = 8
 402:                 _pg.draw.line(screen, overlay_color, (x0 - l, y0 - l), (x0 + l, y0 + l), 2)
 403:                 _pg.draw.line(screen, overlay_color, (x0 - l, y0 + l), (x0 + l, y0 - l), 2)
 404:             elif overlay_text == "MISS":
 405:                 # Draw a white ring
 406:                 x0, y0 = int(overlay_pos[0]), int(overlay_pos[1])
 407:                 _pg.draw.circle(screen, (230, 230, 230), (x0, y0), 9, 2)
 408: 
 409:     pygame.quit()
 410:     return 0
 411: 
 412: 
 413: if __name__ == "__main__":  # pragma: no cover
 414:     raise SystemExit(run())
